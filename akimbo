#!/usr/bin/perl
# vim: set sw=3 ai sm:

use strict;
use integer;

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
#use v5.14; # //u modifier
use utf8;
use open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use Getopt::Long;
use Data::Dumper;
use POSIX;
use JSON::PP;

use vars qw( $debug_p );
use vars qw( $get_p );

use vars qw( $scratch_dir );
use vars qw( $feed_url );

$scratch_dir = 'source';
$feed_url = 'https://akimbo.ca/listings/feed/';

sub get_feed () {
   my $cutoff = strftime '%Y%m%d%H%M', localtime(time - 3600);
   my $now = strftime '%Y%m%d%H%M', localtime;
   my $ok = 0;
   my $h = opendir(DIR, $scratch_dir);
   die "$scratch_dir: opendir: $!\n" unless defined $h;
   for (;;) {
      my $dirent = readdir DIR;
   last unless defined $dirent;
      $ok = 1 if -f "$scratch_dir/$dirent" && $dirent =~ /^\d{12}$/ && $dirent > $cutoff;
   last if $ok;
   }
   closedir DIR;
   if ($ok) {
      print STDERR "get_feed: cache is still valid\n" if $debug_p;
   } else {
      print STDERR "get_feed: cache out of date, need to get new feed\n";
      my @cmd = (
	 'wget',
	 '-U', 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.17) Gecko/20080915 Camino/1.6.4 (MultiLang) (like Firefox/2.0.0.17)',
	 '-O', "$scratch_dir/$now",
	 'https://akimbo.ca/listings/?fwp_listing_type=calls',	# Calls only (don't bother with jobs, events, etc.)
      );
      mkdir $scratch_dir unless -d $scratch_dir;
      my $h = fork;
      die "$cmd[0]: fork: $!\n" unless defined $h;
      if (!$h) {
	 exec { $cmd[0] } @cmd;
	 die "$cmd[0]: exec: $!\n";
      }
      my $st = wait;
      print STDERR "get_feed: command: [(", join('\051 \050', @cmd), ")] returned $st\n" if $debug_p;
   }
}

sub get_post ($) {
}

sub is_gzip ($) {
   my($path) = @_;
   my $it;
   local(*INPUT, $_, $.);
   my @cmd = ('/usr/bin/file', $path);
   my $h = open(INPUT, '-|');
   die "$cmd[0]: fork: $!\n" unless defined $h;
   if (!$h) {
      exec { $cmd[0] } @cmd;
      die "$cmd[0]: exec: $!\n";
   } else {
      my $det = scalar <INPUT>;
      close INPUT;
      $it = $det =~ /gzip/;
   }
   return $it;
}

sub get_file_contents ($) {
   my($path) = @_;
   local(*INPUT, $_, $.);
   my $h;
   my $it;
   if (is_gzip $path) {
      my @cmd = ('/bin/zcat', $path);
      $h = open(INPUT, '-|');
      die "$cmd[0]: fork: $!\n" unless defined $h;
      if (!$h) {
	 exec { $cmd[0] } @cmd;
	 die "$cmd[0]: exec: $!\n";
      }
      print STDERR "get_file_contents: gzip file \"$path\" opened\n" if $debug_p;
   } else {
      $h = open(INPUT, '<', $path);
      die "$path: open: $!\n" unless defined $h;
      print STDERR "get_file_contents: normal file \"$path\" opened\n" if $debug_p;
   }
   for (;;) {
      my $s = scalar <INPUT>;
   last unless defined $s;
      chomp $s;
      $it = [] unless defined $s;
      push @$it, $s;
      print STDERR "get_file_contents: s=($s)\n" if $debug_p > 1;
   }
   close INPUT;
   return $it;
}

sub decode_akimbo_rss_encoded_text ($) {
   my($s) = @_;
   $s =~ s/&#(\d+);/ chr($1); /sge;
   $s =~ s/&amp;/\&/sg;
   $s = $1 if $s =~ /^<!\[CDATA\[(.*?)\]\]>$/s;
   return $s;
}

sub decode_date ($) {
   my($s) = @_;
   my $dow;
   my $time;
   my($year, $month, $day);
   my $sp = "(?:\\s|Â )";
   if ($s =~ /^Sun(?:day)?,?\s+/i) {
      ($s, $dow) = ($', 'U');
   } elsif ($s =~ /^Mon(?:day)?,?\s+/i) {
      ($s, $dow) = ($', 'M');
   } elsif ($s =~ /^Tue(?:s(?:day)?)?,?\s+/i) {
      ($s, $dow) = ($', 'T');
   } elsif ($s =~ /^Wed(?:nes(?:day)?)?,?\s+/i) {
      ($s, $dow) = ($', 'W');
   } elsif ($s =~ /^Thu(?:r(?:s(?:day)?)?)?,?\s+/) {
      ($s, $dow) = ($', 'R');
   } elsif ($s =~ /^Fri(?:day)?,?\s+/i) {
      ($s, $dow) = ($', 'M');
   } elsif ($s =~ /^Sat(?:ur(?:day)?)?,?\s+/i) {
      ($s, $dow) = ($', 'S');
   }
   $s =~ s/\s+(?:at|by)\s+(?=\d)/ /;
   if ($s =~ /$sp+(\d+)(?::(\d\d))?$sp*(?:a\.m\.|AM)$/i) {
      ($s, $time) = ($`, sprintf('%02d:%02d', $1 != 12 && $1, $2));
   } elsif ($s =~ /$sp+(\d+)(?::(\d\d))?$sp*(?:p\.m\.|PM)$/i) {
      ($s, $time) = ($`, sprintf('%02d:%02d', ($1 % 12) + 12, $2));
   }
   $s =~ s/\s*\.$//;
   if ($s =~ /^(\d{1,2})(?:st|nd|rd|th)?$sp+([A-Z][A-Za-z]+),?$sp+(\d{4})$/) {
      ($year, $month, $day) = ($3, $2, $1);
   } elsif ($s =~ /^([A-Z][A-Za-z]+)$sp+(\d{1,2})(?:st|nd|rd|th)?,?$sp+(\d{4})$/) {
      ($year, $month, $day) = ($3, $1, $2);
   }
   $month = 1 if $month =~ /^Jan(?:uary)?$/i;
   $month = 2 if $month =~ /^Feb(?:ruary)?$/i;
   $month = 3 if $month =~ /^Mar(?:ch)?$/i;
   $month = 4 if $month =~ /^Apr(?:il)?$/i;
   $month = 5 if $month =~ /^May$/i;
   $month = 6 if $month =~ /^Jun(?:e)?$/i;
   $month = 7 if $month =~ /^Jul(?:y)?$/i;
   $month = 8 if $month =~ /^Aug(?:ust)?$/i;
   $month = 9 if $month =~ /^Sep(?:t(?:ember)?)?$/i;
   $month = 10 if $month =~ /^Oct(?:ober)?$/i;
   $month = 11 if $month =~ /^Nov(?:ember)?$/i;
   $month = 12 if $month =~ /^Dec(?:ember)?$/i;
   $s = sprintf('%04d-%02d-%02d', $year, $month, $day) if defined $year;
   $s .= "T$time" if defined $time;
   #$s .= " ($dow)" if defined $dow;
   return $s;
}

sub break_data_into_articles ($) {
   my($data) = @_;
   my $it;
   if ($data->[0] =~ /<\?xml/) {
      # RSS - In theory this is all good, but Akimbo doesn't encode real categories (e.g., calls) in the RSS, so it's of limited use
      for my $s (split(/\s*<item>(?:\s*<\/item>\s*)?/s, join("\n", @$data))) {
	 $s =~ s/^.*<channel>.*<item>$//s;			# first item
	 $s =~ s/<\/item>\s*<\/channel>\s*<\/rss>\s*$//s;	# last item
	 $s =~ s/^\s*//s;
	 $s =~ s/\s*$//s;
	 if ($s =~ /<guid\b[^<>]*>(.*?)<\/guid>/s) {
	    my $node = {'guid' => decode_akimbo_rss_encoded_text $1};
	    for my $field ('title', 'link', 'pubDate', 'dc:creator', 'description', 'content:encoded') {
	       $node->{$field} = decode_akimbo_rss_encoded_text $1 if $s =~ /<$field\b[^<>]*>(.*?)<\/$field>/s;
	    }
	    for my $field ('category') {
	       push @{$node->{$field}}, decode_akimbo_rss_encoded_text $1 while $s =~ /<$field\b[^<>]*>(.*?)<\/$field>/sg;
	    }
	    $node->{'deadline'}->{$2} = decode_date($2) while $node->{'content:encoded'} =~ /<(\w+)[^<>]*?class="text-deadline"[^<>]*>([^<>]+)<\/\1>/sg;
	    $node->{'deadline'} = [sort values %{$node->{'deadline'}}];
	    delete $node->{'deadline'} unless @{$node->{'deadline'}};
	    print STDERR "DEBUG: ($s)\n" if $debug_p > 2;
	    print STDERR Dumper($node) if $debug_p > 1;
	    push @$it, $node;
	 }
      }
   } else {
      # The assumption here is this is from an actual listing page
      # Calls only: https://akimbo.ca/listings/?fwp_listing_type=calls
      my $state = 0;
      my $node;
      my $insert_node = sub {
	 print STDERR Dumper($node) if $debug_p > 1;
	 push @$it, $node;
	 $node = undef;
      };
      for my $s (@$data) {
	 if ($state == 0) {
	    if ($s =~ /<div class='card-body'>/) {
	       $state = 1;
	    }
	 } elsif ($state == 1) {
	    if ($s =~ /<a href='.*?fwp_listing_type=\w+'[^<>]*>([^<>]+)<\/a>/) {
	       # FIXME This should apparently be multi-valued because I got a type = Exhibitions from the Calls for Submissions listing (!)
	       $node->{'class'} = $1;
	       $state = 2;
	    }
	 } elsif ($state == 2) {
	    if ($s =~ /<time\b[^<>]*?\bdatetime='([^'']+)'>([^<>]+)<\/time>/) {
	       $node->{'pubDate'} = decode_date $1;
	       $state = 3;
	    }
	 } elsif ($state == 3) {
	    if ($s =~ /<h3[^<>]+><a href='([^'']+)'[^<>]*>([^<>]+)<\/a><\/h3>/) {
	       $node->{'link'} = $1;
	       $node->{'title'} = decode_akimbo_rss_encoded_text $2;
	       $state = 4;
	    }
	 } elsif ($state == 4) {
	    if ($s =~ /^\s*<div[^<>]*>Venue<\/div>\s*$/) {
	       $state = 5;
	    }
	 } elsif ($state == 5) {
	    if ($s =~ /^\s*<div[^<>]*><a href='([^'']+)'[^<>]*>(.*?)<\/a><\/div>\s*$/) {
	       $node->{'venue-link'} = $1;
	       push @{$node->{'venue'}}, $2;
	    } elsif ($s =~ /^\s*<div[^<>]*>(.*?)<\/div>\s*$/) {
	       push @{$node->{'venue'}}, $1;
	    } elsif ($s =~ /^\s*<\/div>\s*$/) {
	       $state = 4;
	    }
	 }
	 if ($s =~ /<div class='card'>/) {
	    &$insert_node if defined $node;
	    $state = 0;
	 }
      }
      &$insert_node if defined $node;
   }
   return $it;
}

sub analyze_data () {
   my $articles;
   my $h = opendir(DIR, $scratch_dir);
   die "$scratch_dir: opendir: $!\n" unless defined $h;
   for (;;) {
      my $dirent = readdir DIR;
   last unless defined $dirent;
      if (-f "$scratch_dir/$dirent") {
	 my $data = get_file_contents "$scratch_dir/$dirent";
	 for my $article (@{ break_data_into_articles $data }) {
	    my $deadlines = $article->{'deadline'};
	    $article->{'effective-deadline'} = !defined $deadlines? 'N/A': @$deadlines == 1? $deadlines->[0]: 'MULTIPLE';
	    $articles->{$article->{'link'}} = $article;
	 }
      }
   }
   closedir DIR;
   return $articles;
}

sub display_listing ($) {
   my($articles) = @_;
   my $fmt = "%-16s  %s\n";
   printf $fmt, 'Deadline', 'Title';
   for my $i (sort { $articles->{$a}->{'effective-deadline'} cmp $articles->{$b}->{'effective-deadline'} } keys %$articles) {
      my $article = $articles->{$i};
      printf $fmt, $article->{'effective-deadline'}, $article->{'title'};
   }
}

GetOptions(
   'debug' => sub { $debug_p += 1; },
   'get' => \$get_p,
) || exit(1);

get_feed;
my $data = analyze_data;
display_listing $data;
